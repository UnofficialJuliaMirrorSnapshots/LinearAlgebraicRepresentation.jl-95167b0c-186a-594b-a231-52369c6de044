using SparseArrays
using LinearAlgebraicRepresentation
using Plasm
Lar = LinearAlgebraicRepresentation


"""
	fix_redundancy(target_mat, ref_mat)
	
*Fix the coboundary_1 matrix*, generated by product ``FV EV^t``, for complexes of *non-convex cells*. The Euler characteristic of 2-sphere is used, where V-E+F=2. Since we have F=2 (inner and outer face) ``V=E`` must hold, and possible `d=E-V` is the (positive) ``defect`` number, called `nfixs` in the code. It equates the number of columns `edges`
whose sum is greater than 2 for the considered row (face). Remember the in a ``d``-complex, *including* the ``outer cell``, all ``(d-1)``-faces must be shared by exactly 2 ``d``-faces. Note that `FV` must include the row of outer shell (exterior face).

# Example

```julia
FV = [[1,2,3,4,5,17,16,12],
[1,2,3,4,6,7,8,9,10,11,12,13,14,15],
[4,5,9,11,12,13,14,15,16,17],
[2,3,6,7], [8,9,10,11]]

FE = [[1,2,3,4,9,20,17,5], 
[1,6,10,7,3,8,11,12,14,15,19,18,16,5],
[4,9,20,17,16,18,19,15,13,8],
[2,10,6,7], [11,12,13,14]]

EV = [[1,2],[2,3],[3,4],[4,5],[1,12],[2,6],[3,7],[4,9],[5,17],[6,7],[8,9],
[8,10],[9,11],[10,11],[11,15],[12,13],[12,16],[13,14],[14,15],[16,17]]

V = [[0 16];[2 16];[5 16];[7 16];[10 16];[2 13];[5 13];[3 11];[7 11];[3 8];[7 8];[0 5];[3 5];[3 2];[7 2];[0 0];[10 0]]

cscFE = u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, false);
Matrix(cscFE)
```

Notice that there are two columns (2 and 13) with 3 ones, hence (3-2)+(3-2)=2 defects to fix. The fixed complex is shown graphically as:

```julia
V = convert(Lar.Points, V')
VV = [[k] for k in 1:size(V,2)];
using Plasm
Plasm.view( Plasm.numbering(2)((V,[VV, EV, FV])) )
```
"""
function fix_redundancy(target_mat, ref_mat)
	nfixs = 0
	faces2fix = []
	edges2fix = []
	for face = 1:size(target_mat,1)
		nedges = sum(findnz(target_mat[face,:])[2])
		nverts = sum(findnz(ref_mat[face,:])[2])
		if nedges != nverts
			nfixs += nedges - nverts
			println("face $face, nedges=$nedges, nverts=$nverts")
			push!(faces2fix,face)
		end
	end
	for edge = 1:size(target_mat,2)
		nfaces = sum(findnz(target_mat[:,edge])[2])
		if nfaces > 2
			println("edge $edge, nfaces=$nfaces")
			push!(edges2fix,edge)
		end
	end
	println("nfixs=$nfixs")
	for i=1:length(faces2fix)
		for j=1:length(edges2fix)
			if target_mat[faces2fix[i], edges2fix[j]]==1
				target_mat[faces2fix[i], edges2fix[j]]=0
			end	
		end
	end
	cscFE = dropzeros(target_mat)
	@assert nnz(cscFE) == 2*size(EV,1)
	return cscFE
end


function u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, convex=true)::Lar.ChainOp
	cscFV = Lar.characteristicMatrix(FV)
	cscEV = Lar.characteristicMatrix(EV)
	temp = cscFV * cscEV'
	I,J,Val = Int64[],Int64[],Int8[]
	for j=1:size(temp,2)
		for i=1:size(temp,1)
			if temp[i,j] == 2
				push!(I,i)
				push!(J,j)
				push!(Val,1)
			end
		end
	end
	cscFE = sparse(I,J,Val)
	if !convex return fix_redundancy(cscFE,cscFV)
	else return cscFE end
end


"""
	coboundary_1( FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp

Generate the *signed* sparse matrix of the coboundary_1 operator.
For each row, start with the first incidence number positive (i.e. assign the orientation of the first edge to the 1-cycle of the face), then bounce back and forth between vertex columns/rows of EV and FE.

# Example

julia> Matrix(cscFE)
5Ã—20 Array{Int8,2}:
 1  1  1  1  1  0  0  0  1  0  0  0  0  0  0  0  1  0  0  1
 1  0  1  0  1  1  1  1  0  1  1  1  0  1  1  1  0  1  1  0
 0  0  0  1  0  0  0  1  1  0  0  0  1  0  1  1  1  1  1  1
 0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0


"""
function coboundary_1( FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp
	# generate unsigned operator's sparse matrix
	cscFE = u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, false)
	# greedy generation of incidence number signs
	cscEV = Lar.coboundary_0( EV::Lar.Cells )
	for f=1:size(cscFE,1)
		uchain = findnz(cscFE[f,:])[1]
	end

end


